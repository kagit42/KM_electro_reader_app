import React, { useEffect, useState, useMemo, useCallback } from 'react';
import {
  FlatList,
  Pressable,
  ScrollView,
  StatusBar,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { colors, fonts } from '../../utils/Theme';
import { SizeConfig } from '../../assets/size/size';
import {
  BarChart,
  DataPointProps,
  LineChart,
} from 'react-native-gifted-charts';
import CustomFromToDatePickerModal from './components/CustomFromToDatePickerModal';
import MaterialIcons from 'react-native-vector-icons/MaterialIcons';
import Ionicons from 'react-native-vector-icons/Ionicons';
import Octicons from 'react-native-vector-icons/Octicons';
import { DrawerNavigationProp } from '@react-navigation/drawer';
import { NavigationType } from '../../navigations/NavigationType';
import { useIsFocused, useNavigation } from '@react-navigation/native';
import { useLazyGetAnalyticsQuery } from '../../redux/slices/ocrSlice';
import { NoInternet } from '../../global/modal/NoInternet';
import { ShowToast } from '../../utils/UtilityFunctions';
import { useNetwork } from '../../ContextApi/NetworkProvider';
import LinearGradient from 'react-native-linear-gradient';
import { Bar, CartesianChart, useChartPressState } from 'victory-native';
import {
  vec,
  Text as SkiaText,
  useFont,
  Path,
  DashPathEffect,
  LinearGradient as SkiaLinearGradient,
} from '@shopify/react-native-skia';
import inter from '../../assets/fonts/InterTight-SemiBold.ttf';
import { useAnimatedReaction } from 'react-native-reanimated';
import { runOnJS } from 'react-native-worklets';

const FILTERS = ['Monthly', 'Custom', 'Biannual', 'Year', '15 days'] as const;
type FilterKey = 'monthly' | 'biannual' | 'year' | '15 days' | 'custom';

type HomeCompProps = DrawerNavigationProp<NavigationType, 'Home'>;

const ExploreMoreAnalytics = () => {
  const [selectedIndex, setSelectedIndex] = useState<number | null>(0);
  const [selectedFilter, setSelectedFilter] = useState<
    Record<FilterKey, boolean>
  >({
    custom: false,
    monthly: true,
    biannual: false,
    year: false,
    '15 days': false,
  });
  const [isVisible, setVisible] = useState(false);
  const [data, setData] = useState<any[]>([]);
  const [peakConsumed, setPeakConsumed] = useState<number>(0);
  const [showNoNetworkModal, setShowNoNetworkModal] = useState(false);
  const [selectedValue, setSelectedValue] = useState<number | null>(null);
  const [selectGrapUi, setGrapUi] = useState(false);
  const [activeItemIndex, setActiveItemIndex] = useState(0);
  const [chartError, setChartError] = useState(false);
  const [isChartReady, setIsChartReady] = useState(false);

  const navigation = useNavigation<HomeCompProps>();
  const [getAnalyticsTrigger] = useLazyGetAnalyticsQuery();

  const isFocused = useIsFocused();
  const { isConnected } = useNetwork();

  // Add error handling for font loading
  const font = useFont(inter, 12);

  // Initialize chart press state with proper error handling
  const { state } = useChartPressState({
    x: '',
    y: { value: 0 },
  });

  const data1 = [
    { label: 'Jan', value: 0 },
    { label: 'Feb', value: 0 },
    { label: 'Mar', value: 0 },
    { label: 'Apr', value: 0 },
    { label: 'May', value: 0 },
    { label: 'Jun', value: 0 },
    { label: 'Jul', value: 0 },
    { label: 'Aug', value: 0 },
    { label: 'Sep', value: 300 },
    { label: 'Oct', value: 0 },
    { label: 'Nov', value: 0 },
    { label: 'Dec', value: 0 },
  ];

  const data2 = [
    { label: '01 Sep', value: 100 },
    { label: '02 Sep', value: 200 },
    { label: '03 Sep', value: 0 },
    { label: '04 Sep', value: 0 },
    { label: '05 Sep', value: 0 },
    { label: '06 Sep', value: 0 },
    { label: '07 Sep', value: 0 },
    { label: '08 Sep', value: 0 },
    { label: '09 Sep', value: 0 },
    { label: '10 Sep', value: 0 },
    { label: '11 Sep', value: 0 },
    { label: '12 Sep', value: 0 },
    { label: '13 Sep', value: 0 },
    { label: '14 Sep', value: 0 },
    { label: '15 Sep', value: 0 },
    { label: '16 Sep', value: 0 },
    { label: '17 Sep', value: 0 },
    { label: '18 Sep', value: 0 },
    { label: '19 Sep', value: 0 },
    { label: '20 Sep', value: 0 },
    { label: '21 Sep', value: 0 },
    { label: '22 Sep', value: 0 },
    { label: '23 Sep', value: 0 },
    { label: '24 Sep', value: 0 },
    { label: '25 Sep', value: 0 },
    { label: '26 Sep', value: 0 },
    { label: '27 Sep', value: 0 },
    { label: '28 Sep', value: 0 },
    { label: '29 Sep', value: 0 },
    { label: '30 Sep', value: 0 },
  ];

  const [toggle, setToggle] = useState(false);

  // Memoized chart domain calculation to handle zero values
  const chartDomain = useMemo(() => {
    if (!data || data.length === 0) {
      return { y: [0, 100] }; // Default domain
    }

    const maxValue = Math.max(...data.map(item => item.value || 0));
    const minValue = Math.min(...data.map(item => item.value || 0));

    // If all values are 0 or very small, set a reasonable domain
    if (maxValue === 0) {
      return { y: [0, 100] };
    }

    // Add some padding to the domain
    const padding = Math.max(maxValue * 0.1, 10);
    return {
      y: [Math.max(0, minValue - padding), maxValue + padding],
    };
  }, [data]);

  // Memoized peak consumed value with fallback
  const safePeakConsumed = useMemo(() => {
    return peakConsumed > 0 ? peakConsumed : 100;
  }, [peakConsumed]);

  const handleFilterPress = useCallback((filter: (typeof FILTERS)[number]) => {
    if (filter !== 'Custom') {
      getAnalytics({ filter: filter });
      console.log('filter : ', filter);
    }

    const key = filter.toLowerCase() as FilterKey;
    setSelectedFilter({
      custom: key === 'custom',
      monthly: key === 'monthly',
      biannual: key === 'biannual',
      year: key === 'year',
      '15 days': key === '15 days',
    });
  }, []);

  const getAnalytics = async ({ filter }: { filter: string }) => {
    try {
      setChartError(false);
      setIsChartReady(false);

      const response = await getAnalyticsTrigger({
        filter:
          filter.toLowerCase() === '15 days' ? '15days' : filter.toLowerCase(),
      });

      if (response?.data?.data) {
        setPeakConsumed(response.data.data.cards?.peak_usage?.kwh || 0);
        setData(response.data.data.usage_breakdown || []);

        setSelectedIndex(0);
        setSelectedValue(response.data.data.usage_breakdown[0]?.value || 0);

        setTimeout(() => {
          setIsChartReady(true);
        }, 500);
      } else {
        setPeakConsumed(0);
        setIsChartReady(true);
      }
    } catch (error) {
      console.log(error);
      setChartError(true);
      setData([]);
      setPeakConsumed(0);
      setIsChartReady(true);
      ShowToast({
        title: 'Something Went Wrong',
        description:
          'It may cause due to unstable internet try again later or different service',
        type: 'error',
      });
    }
  };

  // Fixed animated reaction with proper error handling
  useAnimatedReaction(
    () => state.matchedIndex.value,
    matchedIndex => {
      try {
        if (matchedIndex >= 0 && matchedIndex < data.length && isChartReady) {
          runOnJS(setActiveItemIndex)(matchedIndex);
          // Only update selectedValue, not peakConsumed
          runOnJS(setSelectedValue)(data[matchedIndex]?.value || 0);
        }
      } catch (error) {
        console.log('Animated reaction error:', error);
      }
    },
  );

  useEffect(() => {
    const timer = setTimeout(() => {
      setActiveItemIndex(0);
      // Set initial selected value when chart loads
      if (data.length > 0) {
        setSelectedValue(data[0]?.value || 0);
      }
    }, 1500);

    return () => clearTimeout(timer);
  }, [data]);

  useEffect(() => {
    if (isConnected) {
      setShowNoNetworkModal(false);
      getAnalytics({ filter: 'monthly' });
    } else {
      setShowNoNetworkModal(true);
      ShowToast({
        title: 'No Service Provider',
        description: 'No Internet connection found !',
        type: 'error',
      });
    }
  }, [isConnected]);

  const renderLineChart = () => {
    if (data.length === 0) {
      return (
        <View style={styles.emptyChartContainer}>
          <Text style={styles.emptyChartText}>No data available</Text>
        </View>
      );
    }

    return (
      <LineChart
        data={data.map((item: any, index) => ({
          ...item,
          dataPointText: index === selectedIndex ? item.value + '' : '',
          labelTextStyle: {
            color: index === selectedIndex ? '#334791' : '#3347914F',
          },
        }))}
        focusEnabled
        showStripOnFocus
        textColor1={colors.pureBlack}
        textFontSize1={SizeConfig.fontSize * 4}
        textShiftY={-5}
        textShiftX={10}
        areaChart
        thickness={3}
        height={SizeConfig.height * 55}
        spacing={SizeConfig.width * 10}
        width={SizeConfig.width * 90}
        startOpacity={0.4}
        endOpacity={0}
        yAxisThickness={0}
        xAxisThickness={0}
        rulesThickness={0}
        dashGap={5}
        maxValue={safePeakConsumed * 1.2}
        yAxisTextStyle={styles.axisText}
        xAxisLabelTextStyle={styles.axisTextCenter}
        color1={colors.primary}
        thickness1={SizeConfig.width * 0.4}
        startFillColor={colors.secPrimary}
        endFillColor={colors.secPrimary}
        onFocus={(
          item: { value: number; lable: string; dataPointText: string },
          index: number,
        ) => {
          if (index !== selectedIndex) {
            setSelectedIndex(index);
            setSelectedValue(item.value);
          }
        }}
        showReferenceLine1={selectedValue !== null}
        referenceLine1Position={selectedValue || 0}
        referenceLine1Config={{
          color: colors.secPrimary,
          dashWidth: 4,
          dashGap: 4,
          thickness: 2,
        }}
      />
    );
  };

  const renderBarChart = () => {
    // if (data.length === 0) {
    //   return (
    //     <View style={styles.emptyChartContainer}>
    //       <Text style={styles.emptyChartText}>No data available</Text>
    //     </View>
    //   );
    // }

    // // Add more comprehensive error checking
    // if (chartError || !font || !isChartReady) {
    //   return (
    //     <View style={styles.emptyChartContainer}>
    //       <Text style={styles.emptyChartText}>
    //         {!font
    //           ? 'Loading font...'
    //           : !isChartReady
    //           ? 'Preparing chart...'
    //           : 'Chart loading...'}
    //       </Text>
    //     </View>
    //   );
    // }

    return (
      <ScrollView
        contentContainerStyle={{
          width: toggle
            ? data1.length * SizeConfig.width * 18
            : data2.length * SizeConfig.width * 18,
          height: SizeConfig.height * 60,
          alignItems: 'center',
          justifyContent: 'center',
        }}
        horizontal
        showsHorizontalScrollIndicator={false}
        accessibilityRole="scrollbar"
        accessibilityLabel="Chart data scroll view"
      >
        <CartesianChart
          chartPressState={state}
          xKey="label"
          yKeys={['value']}
          domainPadding={{ left: 60, right: 80, top: 0 }}
          domain={chartDomain}
          animate={{ duration: 500, easing: 'cubicInOut' }}
          xAxis={{
            font,
            tickCount: toggle ? data1.length : data2.length,
            labelColor: 'black',
            lineWidth: 0,
            linePathEffect: <DashPathEffect intervals={[4, 4]} />,
          }}
          frame={{
            lineWidth: 0,
          }}
          yAxis={[
            {
              yKeys: ['value'],
              font,
              linePathEffect: <DashPathEffect intervals={[4, 4]} />,
            },
          ]}
          data={toggle ? data1 : data2}
        >
          {({ points, chartBounds }) => {
            try {
              const activePoint = points.value[activeItemIndex];
              return (
                <>
                  {points.value.map((p, i) => (
                    <Bar
                      key={`bar-${i}`}
                      barCount={points.value.length}
                      points={[p]}
                      barWidth={30}
                      chartBounds={chartBounds}
                      animate={{ type: 'spring' }}
                      innerPadding={0.33}
                      roundedCorners={{
                        topLeft: 7,
                        topRight: 7,
                        bottomLeft: 7,
                        bottomRight: 7,
                      }}
                    >
                      <SkiaLinearGradient
                        start={vec(0, 0)}
                        end={vec(0, chartBounds.bottom)}
                        colors={
                          i === activeItemIndex
                            ? ['#334791', '#334791']
                            : ['#33479151', '#3347914F']
                        }
                      />

                      {i === activeItemIndex && font && (
                        <SkiaText
                          x={p.x - 8}
                          y={(p.y ?? 0) - 10}
                          text={`${Math.round(data1[i].value)}`}
                          font={font}
                          color="black"
                        />
                      )}
                    </Bar>
                  ))}

                  {activePoint && (
                    <Path
                      path={`M ${chartBounds.left} ${activePoint.y} L ${chartBounds.right} ${activePoint.y}`}
                      color={'#334791'}
                      style="stroke"
                      strokeWidth={1}
                    >
                      <DashPathEffect intervals={[6, 6]} />
                    </Path>
                  )}
                </>
              );
            } catch (error) {
              console.log('Chart rendering error:', error);
              return null;
            }
          }}
        </CartesianChart>
      </ScrollView>
    );
  };

  const toggleChartType = useCallback(() => {
    setGrapUi(!selectGrapUi);
  }, [selectGrapUi]);

  console.log('Data:', data);
  console.log('Peak Consumed:', peakConsumed);
  console.log('Selected Value:', selectedValue);
  console.log('Chart Ready:', isChartReady);
  console.log('Font Loaded:', !!font);

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar backgroundColor={'#1B2F50'} barStyle={'light-content'} />

      <CustomFromToDatePickerModal
        isVisible={isVisible}
        setVisible={setVisible}
      />

      {isFocused && showNoNetworkModal && (
        <NoInternet showNoNetworkModal={true} />
      )}

      <View style={styles.analyticsContainer}>
        <LinearGradient
          colors={[colors.primary, '#1B2F50']}
          start={{ x: 0, y: 1 }}
          end={{ x: 0, y: 0 }}
          style={styles.linearGradient}
        >
          <View style={styles.header}>
            <TouchableOpacity
              activeOpacity={0.5}
              style={styles.headerBackBtnComp}
              onPress={() => navigation.goBack()}
              accessibilityRole="button"
              accessibilityLabel="Go back"
            >
              <Octicons
                name="arrow-left"
                size={SizeConfig.width * 5}
                color={colors.pureBlack}
              />
            </TouchableOpacity>
            <Text style={styles.headerTitle}>Explore More</Text>
          </View>

          <View style={styles.flatListMainComp}>
            <FlatList
              horizontal
              data={FILTERS}
              keyExtractor={item => item}
              contentContainerStyle={styles.filterList}
              showsHorizontalScrollIndicator={false}
              renderItem={({ item }) => {
                const key = item.toLowerCase() as FilterKey;
                const isActive = selectedFilter[key];

                return (
                  <Pressable
                    onPress={() => {
                      handleFilterPress(item);
                      if (item === 'Custom') {
                        setVisible(true);
                      }
                    }}
                    style={[
                      styles.filterBtnComp,
                      isActive && styles.filterBtnActive,
                    ]}
                    accessibilityRole="button"
                    accessibilityLabel={`Filter by ${item}`}
                    accessibilityState={{ selected: isActive }}
                  >
                    <Text style={styles.filterBtnText}>{item}</Text>
                  </Pressable>
                );
              }}
            />
          </View>

          <View>
            <Text style={styles.subTitle}>Electricity usage</Text>
            <Text style={styles.mainValue}>{selectedValue || 0} kWh</Text>
          </View>
        </LinearGradient>

        <TouchableOpacity
          // onPress={toggleChartType}
          onPress={() => setToggle(!toggle)}
          style={styles.changeGrapUiComp}
          hitSlop={20}
          accessibilityRole="button"
          accessibilityLabel={`Switch to ${
            selectGrapUi ? 'bar' : 'line'
          } chart`}
        >
          {selectGrapUi ? (
            <MaterialIcons
              name="analytics"
              size={SizeConfig.width * 7}
              color={colors.primary}
            />
          ) : (
            <Ionicons
              name="analytics-sharp"
              size={SizeConfig.width * 7}
              color={colors.primary}
            />
          )}
        </TouchableOpacity>

        <View style={styles.renderMultiGrapMainComp}>
          {selectGrapUi ? renderLineChart() : renderBarChart()}
        </View>
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#1B2F50',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: SizeConfig.width * 4,
  },
  headerBackBtnComp: {
    backgroundColor: colors.white,
    width: SizeConfig.width * 8,
    height: SizeConfig.width * 8,
    borderRadius: (SizeConfig.width * 8) / 2,
    alignItems: 'center',
    justifyContent: 'center',
  },
  headerTitle: {
    fontFamily: fonts.regular,
    fontSize: SizeConfig.fontSize * 5,
    color: colors.white,
    width: '100%',
  },
  headerText: {
    fontFamily: fonts.medium,
    fontSize: SizeConfig.fontSize * 3.9,
    color: colors.black,
    flex: 1,
    textAlign: 'center',
    paddingRight: SizeConfig.width * 10,
  },
  analyticsContainer: {
    backgroundColor: colors.white,
    gap: SizeConfig.height,
  },
  subTitle: {
    fontFamily: fonts.regular,
    fontSize: SizeConfig.fontSize * 4,
    color: colors.white,
  },
  mainValue: {
    fontFamily: fonts.semiBold,
    fontSize: SizeConfig.fontSize * 5.2,
    color: colors.white,
  },
  axisText: {
    color: '#979797',
  },
  axisTextCenter: {
    color: '#979797',
    textAlign: 'center',
  },
  filterList: {
    gap: SizeConfig.width,
    justifyContent: 'space-between',
    paddingHorizontal: SizeConfig.width * 2,
  },
  filterBtnComp: {
    padding: SizeConfig.width * 2,
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: SizeConfig.width * 5,
    paddingHorizontal: SizeConfig.width * 5,
  },
  filterBtnActive: {
    backgroundColor: colors.white,
    borderWidth: 0.5,
    borderColor: colors.borderColor,
  },
  filterBtnText: {
    fontFamily: fonts.medium,
    fontSize: SizeConfig.fontSize * 3.3,
    color: colors.pureBlack,
  },
  exitFullScreen: {
    flexDirection: 'row',
    gap: SizeConfig.width,
    backgroundColor: colors.success,
    padding: SizeConfig.width,
    paddingHorizontal: SizeConfig.width * 3,
    paddingVertical: SizeConfig.height,
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: SizeConfig.width * 3,
  },
  exitFullScrrenBtnText: {
    fontFamily: fonts.semiBold,
    fontSize: SizeConfig.fontSize * 3.3,
    color: colors.black,
  },
  linearGradient: {
    paddingHorizontal: SizeConfig.width * 6,
    paddingTop: SizeConfig.height * 2,
    gap: SizeConfig.height * 2,
    paddingBottom: SizeConfig.height * 4,
    borderBottomRightRadius: SizeConfig.width * 7,
    borderBottomLeftRadius: SizeConfig.width * 7,
  },
  flatListMainComp: {
    paddingVertical: SizeConfig.height * 0.5,
    backgroundColor: '#c8ccd4',
    borderRadius: SizeConfig.width * 10,
    overflow: 'hidden',
  },
  changeGrapUiComp: {
    position: 'absolute',
    top: SizeConfig.height * 29,
    right: SizeConfig.width * 5,
    zIndex: 3,
  },
  renderMultiGrapMainComp: {
    paddingHorizontal: SizeConfig.width * 4,
    paddingTop: SizeConfig.height * 3,
    height: '100%',
  },
  emptyChartContainer: {
    height: SizeConfig.height * 55,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
    borderRadius: SizeConfig.width * 2,
  },
  emptyChartText: {
    fontFamily: fonts.medium,
    fontSize: SizeConfig.fontSize * 4,
    color: '#666',
    textAlign: 'center',
  },
});

export default ExploreMoreAnalytics;
