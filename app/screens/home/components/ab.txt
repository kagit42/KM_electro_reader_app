import React, { useEffect, useRef, useState } from 'react';
import {
  Text,
  TouchableOpacity,
  View,
  StyleSheet,
  ActivityIndicator,
  ScrollView,
} from 'react-native';
import { Bar } from 'victory-native';
import { SizeConfig } from '../../../assets/size/size';
import { colors, fonts } from '../../../utils/Theme';
import MaterialIcons from 'react-native-vector-icons/MaterialIcons';
import { useNavigation } from '@react-navigation/native';
import { DrawerNavigationProp } from '@react-navigation/drawer';
import { NavigationType } from '../../../navigations/NavigationType';
import { CartesianChart, useChartPressState } from 'victory-native';
import {
  DashPathEffect,
  LinearGradient,
  Path,
  Text as SkiaText,
  useFont,
  vec,
} from '@shopify/react-native-skia';
import inter from '../../../assets/fonts/InterTight-SemiBold.ttf';
import { useAnimatedReaction, useSharedValue } from 'react-native-reanimated';
import { runOnJS } from 'react-native-worklets';

type HomeCompProps = DrawerNavigationProp<NavigationType, 'Home'>;

type DataPoint = { label: string; value: number };

const GrapAnalytics = ({ data = [], isLoading }: { data?: DataPoint[]; isLoading?: boolean }) => {
  const safeData: DataPoint[] = Array.isArray(data)
    ? data
        .map(d => ({
          label: typeof d?.label === 'string' ? d.label : String(d?.label ?? ''),
          value: Number.isFinite(Number(d?.value)) ? Number(d.value) : 0,
        }))
        .filter(d => d.label.length > 0)
    : [];

  const navigation = useNavigation<HomeCompProps>();

  const [selectedIndex, setSelectedIndex] = useState<number | null>(0);
  const [selectedValue, setSelectedValue] = useState<number | null>(null);
  const [activeItemIndex, setActiveItemIndex] = useState(0);
  const [isChartReady, setIsChartReady] = useState(false);

  const font = useFont(inter, 12);

  const { state } = useChartPressState({
    x: '',
    y: { value: 0 },
  });

  // Track mount to avoid runOnJS setState after unmount
  const mountedRef = useRef(true);
  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
    };
  }, []);

  // Gate worklet reaction from native side
  const reactionEnabled = useSharedValue(0);

  useEffect(() => {
    if (safeData.length > 0) {
      setSelectedValue(typeof safeData[0].value === 'number' ? safeData[0].value : null);
      setSelectedIndex(0);
      setActiveItemIndex(0);
    } else {
      setSelectedValue(null);
      setSelectedIndex(null);
      setActiveItemIndex(0);
    }
  }, [safeData]);

  useEffect(() => {
    if (font) {
      const t = setTimeout(() => {
        if (mountedRef.current) {
          setIsChartReady(true);
          reactionEnabled.value = 1;
        }
      }, 20);
      return () => {
        clearTimeout(t);
        reactionEnabled.value = 0;
      };
    } else {
      setIsChartReady(false);
      reactionEnabled.value = 0;
    }
  }, [font, reactionEnabled]);

  // Clamp active index when data changes
  useEffect(() => {
    if (safeData.length === 0) return;
    setActiveItemIndex(i => {
      const next = typeof i === 'number' ? i : 0;
      return Math.min(Math.max(0, next), safeData.length - 1);
    });
  }, [safeData.length]);

  // Defensive domain (no useMemo per request)
  const computeDomain = (arr: DataPoint[]) => {
    if (!Array.isArray(arr) || arr.length === 0) return { y: [0, 100] };
    const nums = arr.map(x => (Number.isFinite(x?.value) ? Number(x.value) : 0));
    const maxValue = Math.max(...nums, 0);
    const minValue = Math.min(...nums, 0);
    if (maxValue <= 0 && minValue >= 0) return { y: [0, 100] };
    const padding = Math.max(maxValue * 0.1, 10);
    return { y: [Math.max(0, minValue - padding), maxValue + padding] };
  };
  const chartDomain = computeDomain(safeData);

  // Use a stable handler to avoid setState after unmount
  const setActiveAndValue = (idx: number) => {
    if (!mountedRef.current) return;
    const clamped = Math.min(Math.max(0, idx), Math.max(safeData.length - 1, 0));
    setActiveItemIndex(clamped);
    setSelectedValue(Number(safeData[clamped]?.value ?? 0));
    setSelectedIndex(clamped);
  };

  useAnimatedReaction(
    () => state.matchedIndex.value,
    matchedIndex => {
      try {
        if (reactionEnabled.value !== 1) return;
        if (
          typeof matchedIndex === 'number' &&
          matchedIndex >= 0 &&
          matchedIndex < safeData.length &&
          isChartReady
        ) {
          runOnJS(setActiveAndValue)(matchedIndex);
        }
      } catch (error) {
        if (__DEV__) console.log('Animated reaction error:', error);
      }
    },
    [safeData.length, isChartReady],
  );

  if (!font) {
    return (
      <View style={styles.emptyChartContainer}>
        <Text style={styles.emptyChartText}>Loading font...</Text>
      </View>
    );
  }

  if (!safeData || safeData.length === 0) {
    return (
      <View style={styles.emptyChartContainer}>
        <Text style={styles.emptyChartText}>No data available</Text>
      </View>
    );
  }

  const containerWidth = Math.min(Math.max(500, safeData.length * SizeConfig.width * 10), 4000);

  return (
    <View style={styles.container}>
      <View
        style={{
          position: 'absolute',
          width: '100%',
          height: '100%',
          alignItems: 'center',
          justifyContent: 'center',
          display: isLoading ? 'flex' : 'none',
          zIndex: 2,
        }}
      >
        <ActivityIndicator size={'large'} color={colors.primary} />
      </View>

      <View style={styles.headerRow}>
        <View>
          <Text style={styles.subTitle}>Electricity usage</Text>
          <Text ellipsizeMode="tail" numberOfLines={1} style={styles.mainValue}>
            {selectedValue ?? 0} KWh
          </Text>
        </View>

        <TouchableOpacity
          onPress={() => {
            navigation.navigate('ExploreMoreAnalytics');
          }}
          activeOpacity={0.5}
          style={styles.iconWrapper}
        >
          <MaterialIcons
            name="open-in-full"
            size={SizeConfig.width * 4}
            color={colors.black}
          />
        </TouchableOpacity>
      </View>

      <ScrollView
        contentContainerStyle={{
          width: containerWidth,
          height: SizeConfig.height * 25,
          alignItems: 'center',
          justifyContent: 'center',
        }}
        horizontal
        showsHorizontalScrollIndicator={false}
      >
        {isChartReady ? (
          <CartesianChart
            // Avoid forcing remounts via changing key; remounts can race with worklets/Skia teardown
            chartPressState={state}
            xKey="label"
            yKeys={['value']}
            domainPadding={{ left: 60, right: 80, top: 0 }}
            domain={chartDomain}
            animate={{ duration: 500, easing: 'cubicInOut' }}
            xAxis={{
              font,
              tickCount: Math.min(10, safeData.length),
              labelColor: 'black',
              lineWidth: 0,
              linePathEffect: <DashPathEffect intervals={[4, 4]} />,
            }}
            frame={{
              lineWidth: 0,
            }}
            yAxis={[
              {
                yKeys: ['value'],
                font,
                lineWidth: 0,
                linePathEffect: <DashPathEffect intervals={[4, 4]} />,
              },
            ]}
            data={safeData}
          >
            {({ points, chartBounds }) => {
              try {
                const pts = points.value || [];
                const safeIndex = Math.min(
                  Math.max(0, activeItemIndex),
                  Math.max(pts.length - 1, 0),
                );
                const activePoint = pts[safeIndex];

                return (
                  <>
                    {pts.map((p: any, i: number) => {
                      const isActive = i === safeIndex;
                      // Guard NaN coordinates
                      const px = Number.isFinite(p?.x) ? p.x : 0;
                      const py = Number.isFinite(p?.y) ? p.y : chartBounds.bottom;

                      return (
                        <Bar
                          key={`bar-${i}`}
                          barCount={pts.length}
                          points={[{ ...p, x: px, y: py }]}
                          barWidth={30}
                          chartBounds={chartBounds}
                          innerPadding={0.33}
                          roundedCorners={{
                            topLeft: 7,
                            topRight: 7,
                            bottomLeft: 7,
                            bottomRight: 7,
                          }}
                        >
                          <LinearGradient
                            start={vec(0, 0)}
                            end={vec(0, chartBounds.bottom)}
                            colors={
                              isActive ? ['#334791', '#334791'] : ['#33479151', '#3347914F']
                            }
                          />

                          {isActive && font && safeData[i] && Number.isFinite(py) && (
                            <SkiaText
                              x={px - 8}
                              y={(py ?? 0) - 10}
                              text={`${Math.round(Number(safeData[i].value ?? 0))}`}
                              font={font}
                              color="black"
                            />
                          )}
                        </Bar>
                      );
                    })}

                    {activePoint &&
                      Number.isFinite(activePoint.y) &&
                      Number.isFinite(chartBounds.left) &&
                      Number.isFinite(chartBounds.right) && (
                        <Path
                          path={`M ${chartBounds.left} ${activePoint.y} L ${chartBounds.right} ${activePoint.y}`}
                          color={'#334791'}
                          style="stroke"
                          strokeWidth={1}
                        >
                          <DashPathEffect intervals={[6, 6]} />
                        </Path>
                      )}
                  </>
                );
              } catch (error) {
                if (__DEV__) console.log('Chart rendering error:', error);
                return null;
              }
            }}
          </CartesianChart>
        ) : (
          <View style={styles.emptyChartContainer}>
            <Text style={styles.emptyChartText}>Preparing chart…</Text>
          </View>
        )}
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    backgroundColor: colors.white,
    overflow: 'hidden',
    gap: SizeConfig.height * 2,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  subTitle: {
    fontFamily: fonts.regular,
    fontSize: SizeConfig.fontSize * 4,
    color: colors.pureBlack,
  },
  mainValue: {
    fontFamily: fonts.semiBold,
    fontSize: SizeConfig.fontSize * 4,
    color: colors.pureBlack,
    width: SizeConfig.width * 45,
  },
  iconWrapper: {
    width: SizeConfig.width * 8,
    height: SizeConfig.width * 8,
    backgroundColor: colors.white,
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: (SizeConfig.width * 8) / 2,
    elevation: 3,
    marginRight: SizeConfig.width,
    marginTop: SizeConfig.width,
  },
  axisText: {
    color: '#979797',
  },
  axisTextCenter: {
    color: '#979797',
    textAlign: 'center',
  },
  emptyChartContainer: {
    height: SizeConfig.height * 25,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: colors.white,
    borderRadius: SizeConfig.width * 2,
  },
  emptyChartText: {
    fontFamily: fonts.medium,
    fontSize: SizeConfig.fontSize * 4,
    color: '#666',
    textAlign: 'center',
  },
});

export default GrapAnalytics;